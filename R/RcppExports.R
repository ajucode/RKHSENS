# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Generic weighted p-distance
#' @description Many isotropic models can be defined employing a distance. In particular this 
#' function implements a distance employing weights and different powers.
#' @param x First vector.
#' @param y Second vector.
#' @param w Weights for every coordinate in the vectors.
#' @param p Powers for every coordinate in the vectors. To define a true norm every coordinate
#' has to be greater than 1.
#' @return Real value of the weighted p-distance.
#' @author Pedro Guarderas \email{pedro.felipe.guarderas@@gmail.com}.
#' @export
weight_pow_dist <- function(x, y, w, p) {
    .Call('_KRIG_weight_pow_dist', PACKAGE = 'KRIG', x, y, w, p)
}

#' @title One coordinate kernel integral.
#' @description This function is part of the routines employed in the sensitivity analysis, takes 
#' the kernel \eqn{k} and for each fixed coordinate in \eqn{x}, the integral in the second 
#' variable \eqn{y}, is computed in the interval \eqn{a} to \eqn{b} by taking \eqn{n} uniform
#' steps.
#' @param Kern Kernel function.
#' @param x Column vector with values for the first coordinate of the kernel.
#' @param a Inferior limit for the integral in y.
#' @param b Superior limit for the integral in y.
#' @param n Number of uniform division to compute the integral.
#' @return Vector with integrals while the x coordinate is fixed.
#' @author Pedro Guarderas \email{pedro.felipe.guarderas@@gmail.com}.
#' @export
vector_integrate_kernel <- function(Kern, x, a, b, n) {
    .Call('_KRIG_vector_integrate_kernel', PACKAGE = 'KRIG', Kern, x, a, b, n)
}

#' @title Complete kernel integral.
#' @description This function is part of the routines employed in the sensitivity analysis, 
#' calculate the integral in both coordinate \eqn{x} and \eqn{y} of the kernel, over the square
#' domain give by the limits \eqn{a} and \eqn{b}. 
#' @param Kern Kernel function.
#' @param a Inferior limit for the integral in each coordinate.
#' @param b Superior limit for the integral in each coordinate.
#' @param n Number of uniform division to compute the integral.
#' @return Real value with the integral value.
#' @author Pedro Guarderas \email{pedro.felipe.guarderas@@gmail.com}.
#' @export
complete_integrate_kernel <- function(Kern, a, b, n) {
    .Call('_KRIG_complete_integrate_kernel', PACKAGE = 'KRIG', Kern, a, b, n)
}

#' @title Integrals of a list of kernels.
#' @description This function is part of the routines employed in the sensitivity analysis, 
#' computes vector of integrals and complete integrals of kernels specified in the data frame
#' Kernels.
#' @param Kernels data.frame of kernels composed by four columns.
#' \enumerate{
#'   \item Kernel name.
#'   \item Inferior limit for integral.
#'   \item Superior limit for integral.
#'   \item Number of steps for discretization of integrals.
#' }
#' @param X matrix containing in each row the coordinate where the one coordinate integrals will 
#' be evaluated.
#' @return List with one coordinate integrals and complete kernel integrals.
#' @author Pedro Guarderas \email{pedro.felipe.guarderas@@gmail.com}.
#' @export
list_integrate_kernel <- function(Kernels, X) {
    .Call('_KRIG_list_integrate_kernel', PACKAGE = 'KRIG', Kernels, X)
}

#' @title KANOVA Kernel anova under RKHS approximations.
#' @description Under an approximation to the sensitivity analysis based in variance computation
#' the different indexes of combinatorial sensitivity values can be computed employing the
#' values of kernel integrals.
#' @param Kernels data.frame of kernels composed by four columns.
#' \enumerate{
#'   \item Kernel name.
#'   \item Inferior limit for integral.
#'   \item Superior limit for integral.
#'   \item Number of steps for discretization of integrals.
#' }
#' @param Integral A list containing the results of kernel integrals of the functions
#' \code{\link{vector_integrate_kernel}}.
#' @param X matrix containing in each row the coordinate where the one coordinate integrals will 
#' be evaluated.
#' @return List with contaning the Gamma 3D array where the different combination variance are
#' stocked and the total matrix variance named Kanova. 
#' @author Pedro Guarderas \email{pedro.felipe.guarderas@@gmail.com}.
#' @export
Kanova <- function(Kernels, Integral, X) {
    .Call('_KRIG_Kanova', PACKAGE = 'KRIG', Kernels, Integral, X)
}

#' @title Linear kernel
#' @description
#' @param h
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
linear_kernel <- function(x, y, alpha) {
    .Call('_KRIG_linear_kernel', PACKAGE = 'KRIG', x, y, alpha)
}

#' @title Polynomial kernel
#' @description
#' @param x
#' @param y
#' @param alpha
#' @param beta
#' @param n
#' @return Real value
#' @author Pedro Guarderas
#' @export
polynomial_kernel <- function(x, y, alpha, beta, n) {
    .Call('_KRIG_polynomial_kernel', PACKAGE = 'KRIG', x, y, alpha, beta, n)
}

#' @title Square kernel
#' @description
#' @param h
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
square_kernel <- function(h, alpha = 1.0) {
    .Call('_KRIG_square_kernel', PACKAGE = 'KRIG', h, alpha)
}

#' @title Triangular kernel
#' @description
#' @param h
#' @param c
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
triangular_kernel <- function(h, c = 1.0, alpha = 1.0) {
    .Call('_KRIG_triangular_kernel', PACKAGE = 'KRIG', h, c, alpha)
}

#' @title Exponential kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
exp_kernel <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('_KRIG_exp_kernel', PACKAGE = 'KRIG', h, sigma, theta)
}

#' @title Gaussian kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
gaussian_kernel <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('_KRIG_gaussian_kernel', PACKAGE = 'KRIG', h, sigma, theta)
}

#' @title Spherical kernel
#' @description
#' @param h
#' @param phi
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
spherical_kernel <- function(h, phi, theta) {
    .Call('_KRIG_spherical_kernel', PACKAGE = 'KRIG', h, phi, theta)
}

#' @title MatÃ©rn kernel
#' @description
#' @param h
#' @param v
#' @param sigma
#' @return Real value
#' @author Pedro Guarderas
#' @export
matern_kernel <- function(h, v = 2.0, sigma = 1.0, theta = 1.0) {
    .Call('_KRIG_matern_kernel', PACKAGE = 'KRIG', h, v, sigma, theta)
}

#' @title Multilog kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
multilog_kernel <- function(h, R = 1.0) {
    .Call('_KRIG_multilog_kernel', PACKAGE = 'KRIG', h, R)
}

#' @title Natural cubic spline kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
nat_cubic_spline_kernel <- function(h, R = 1.0) {
    .Call('_KRIG_nat_cubic_spline_kernel', PACKAGE = 'KRIG', h, R)
}

#' @title Thin plate kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
thin_plate_kernel <- function(h, R = 1.0) {
    .Call('_KRIG_thin_plate_kernel', PACKAGE = 'KRIG', h, R)
}

#' @title Mix kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
mix_kernel <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('_KRIG_mix_kernel', PACKAGE = 'KRIG', h, sigma, theta)
}

#' @title Spatial covariance matrix.
#' @description To compute a Gaussian regression or interpolation is necessary use Kernel, and
#'   it is requeried to construct the spatial convariance matrix. The spatial covariance could
#'   be estimated between to sets of points X and Y and the result is not necessarily a square
#'   matrix.
#' @param X First set of spatial points.
#' @param Y Second set of spatial points.
#' @param Kern Kernel function.
#' @param symmetric If result of computation will be a square matrix, the time computation can
#'   be improved setting this parameter to TRUE, the default is FALSE.
#' @return The spatial covariance matrix.
#' @author Pedro Guarderas
#' @useDynLib KRIG
#' @importFrom Rcpp sourceCpp
#' @exportPattern("^[[:alpha:]]+")
#' @export
Kov <- function(X, Y, Kern, symmetric = FALSE) {
    .Call('_KRIG_Kov', PACKAGE = 'KRIG', X, Y, Kern, symmetric)
}

#' @title Gaussian regression
#' @description Computes Gaussian regression with a given covariance kernel
#' @param Z Observed spatial values.
#' @param X Spatial points, ubication where the Z value was observed.
#' @param Y Spatial points where it is requested to predict Z.
#' @param Kern Kernel functions.
#' @param type Type of Gaussian regression, 0 = simple interpolation, 1 = simple regression, 
#'  2 = ordinary interpolation, 3 = ordinary regression, 4 = universal interpolation, 
#'  5 = universal regression.
#' @param cinv Form to compute the inverse.
#' @return List containing the different important matrices employed for the Gaussian regression.
#' \item{W}{Predicted new values for Z}
#' \item{K}{Covariance matrix for X}
#' \item{k}{Covariance matrix between Y and X}
#' \item{J}{Inverse of the covariance matrix}
#' @author Pedro Guarderas
#' @export
Krig <- function(Z, K, k, G, g, type = "ordinary", typeinv = "syminv") {
    .Call('_KRIG_Krig', PACKAGE = 'KRIG', Z, K, k, G, g, type, typeinv)
}

#' @title Sensitiviy analysis
#' @description Computation of Sobol index
#' @param KF 
#' @param comb Combination.
#' @param X Points grid.
#' @param Gamma Cube with integral results.
#' @return Real value of sensitivity.
#' @author Pedro Guarderas
#' @export
sens_idx <- function(KF, comb, X, Gamma) {
    .Call('_KRIG_sens_idx', PACKAGE = 'KRIG', KF, comb, X, Gamma)
}

#' @title Var
#' @description Computation of variance
#' @param Gamma Cube with integral results.
#' @return Real value of sensitivity.
#' @author Pedro Guarderas
#' @export
sens_var <- function(KF, Gamma) {
    .Call('_KRIG_sens_var', PACKAGE = 'KRIG', KF, Gamma)
}

