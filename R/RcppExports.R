# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Generic function to compute distances
#' @description This function computes a weighted distance between vectors x and y
#' @param x
#' @param y
#' @param w weights
#' @param p power terms
#' @return Numeric value with the distance
#' @author Pedro Guarderas
#' @export
RKHWeightPowDist <- function(x, y, w, p) {
    .Call('RKHSENS_RKHWeightPowDist', PACKAGE = 'RKHSENS', x, y, w, p)
}

#' @title  Covariance kernel matrix
#' @description Computes covariance kernel matrix
#' @param X
#' @param Y
#' @param k Kernel
#' @param symmetric check if matrix will be symmetric
#' @return Covariance matrix
#' @author Pedro Guarderas
#' @useDynLib RKHSENS
#' @importFrom Rcpp sourceCpp evalCpp
#' @exportPattern("^[[:alpha:]]+")
#' @export
RKHCov <- function(X, Y, Kern, symmetric = FALSE) {
    .Call('RKHSENS_RKHCov', PACKAGE = 'RKHSENS', X, Y, Kern, symmetric)
}

#' @title Gaussian regression
#' @description Computes Gaussian regression with a given covariance kernel
#' @param Z
#' @param X
#' @param Y 
#' @param Kern kernel
#' @return List
#' @author Pedro Guarderas
#' @export
RKHGaussProcess <- function(Z, X, Y, Kern) {
    .Call('RKHSENS_RKHGaussProcess', PACKAGE = 'RKHSENS', Z, X, Y, Kern)
}

#' @title Linear kernel
#' @description
#' @param h
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerLinear <- function(h, alpha = 1.0) {
    .Call('RKHSENS_RKHKerLinear', PACKAGE = 'RKHSENS', h, alpha)
}

#' @title Square kernel
#' @description
#' @param h
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerSqr <- function(h, alpha = 1.0) {
    .Call('RKHSENS_RKHKerSqr', PACKAGE = 'RKHSENS', h, alpha)
}

#' @title Triangular kernel
#' @description
#' @param h
#' @param c
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerTri <- function(h, c = 1.0, alpha = 1.0) {
    .Call('RKHSENS_RKHKerTri', PACKAGE = 'RKHSENS', h, c, alpha)
}

#' @title Exponential kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerExp <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('RKHSENS_RKHKerExp', PACKAGE = 'RKHSENS', h, sigma, theta)
}

#' @title Gaussian kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerSqrExp <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('RKHSENS_RKHKerSqrExp', PACKAGE = 'RKHSENS', h, sigma, theta)
}

#' @title MatÃ©rn kernel
#' @description
#' @param h
#' @param v
#' @param sigma
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerMatern <- function(h, v = 2.0, sigma = 1.0, theta = 1.0) {
    .Call('RKHSENS_RKHKerMatern', PACKAGE = 'RKHSENS', h, v, sigma, theta)
}

#' @title Multilog kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerMultilog <- function(h, R = 1.0) {
    .Call('RKHSENS_RKHKerMultilog', PACKAGE = 'RKHSENS', h, R)
}

#' @title Natural cubic spline kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerNatCubSpl <- function(h, R = 1.0) {
    .Call('RKHSENS_RKHKerNatCubSpl', PACKAGE = 'RKHSENS', h, R)
}

#' @title Thin plate kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerPlateSpl <- function(h, R = 1.0) {
    .Call('RKHSENS_RKHKerPlateSpl', PACKAGE = 'RKHSENS', h, R)
}

#' @title Mix kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerMix <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('RKHSENS_RKHKerMix', PACKAGE = 'RKHSENS', h, sigma, theta)
}

