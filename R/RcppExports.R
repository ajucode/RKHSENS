# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Generic weighted p-distance
#' @description Many isotropic models can be defined employing a distance. In particular this 
#' function implements a distance employing weights and different powers.
#' @param x First vector
#' @param y Second vector
#' @param w Weights for every coordinate in the vectors
#' @param p Powers for every coordinate in the vectors. To define a true norm every coordinate
#' has to be greater than 1.
#' @return Numeric value of the weighted p-distance.
#' @author Pedro Guarderas
#' @export
RKHWeightPowDist <- function(x, y, w, p) {
    .Call('RKHSENS_RKHWeightPowDist', PACKAGE = 'RKHSENS', x, y, w, p)
}

#' @title Spatial covariance matrix.
#' @description To compute a Gaussian regression or interpolation is necessary use Kernel, and
#'   it is requeried to construct the spatial convariance matrix. The spatial covariance could
#'   be estimated between to sets of points X and Y and the result is not necessarily a square
#'   matrix.
#' @param X First set of spatial points.
#' @param Y Second set of spatial points.
#' @param Kern Kernel function.
#' @param symmetric If result of computation will be a square matrix, the time computation can
#'   be improved setting this parameter to TRUE, the default is FALSE.
#' @return The spatial covariance matrix.
#' @author Pedro Guarderas
#' @useDynLib RKHSENS
#' @importFrom Rcpp sourceCpp
#' @exportPattern("^[[:alpha:]]+")
#' @export
RKHCov <- function(X, Y, Kern, symmetric = FALSE) {
    .Call('RKHSENS_RKHCov', PACKAGE = 'RKHSENS', X, Y, Kern, symmetric)
}

#' @title Gaussian regression
#' @description Computes Gaussian regression with a given covariance kernel
#' @param Z Observed spatial values.
#' @param X Spatial points, ubication where the Z value was observed.
#' @param Y Spatial points where it is requested to predict Z.
#' @param Kern Kernel functions.
#' @param type Type of Gaussian regression, 0 = simple interpolation, 1 = simple regression, 
#'  2 = ordinary interpolation, 3 = ordinary regression, 4 = universal interpolation, 
#'  5 = universal regression.
#' @param cinv Form to compute the inverse.
#' @return List containing the different important matrices employed for the Gaussian regression.
#' \item{W}{Predicted new values for Z}
#' \item{K}{Covariance matrix for X}
#' \item{k}{Covariance matrix between Y and X}
#' \item{J}{Inverse of the covariance matrix}
#' @author Pedro Guarderas
#' @export
RKHEstimate <- function(Z, K, k, G, g, type = "ordinary", typeinv = "syminv") {
    .Call('RKHSENS_RKHEstimate', PACKAGE = 'RKHSENS', Z, K, k, G, g, type, typeinv)
}

#' @title Vector integral
#' @description Computes covariance kernel matrix
#' @param Kern
#' @param x
#' @param a
#' @param b
#' @param n
#' @return Vector with integrals
#' @author Pedro Guarderas
#' @export
RKHIntegrateKern <- function(Kern, x, a, b, n) {
    .Call('RKHSENS_RKHIntegrateKern', PACKAGE = 'RKHSENS', Kern, x, a, b, n)
}

#' @title Complete kernel integral
#' @description Complete kernel integral
#' @param Kern
#' @param a
#' @param b
#' @param n
#' @return Real
#' @author Pedro Guarderas
#' @export
RKHCompIntegKern <- function(Kern, a, b, n) {
    .Call('RKHSENS_RKHCompIntegKern', PACKAGE = 'RKHSENS', Kern, a, b, n)
}

#' @title Integrals of kernels
#' @description Compute integrals of kernels
#' @param Kernels List of kernels
#' @return List with vector integrals and complete kernel integrals
#' @author Pedro Guarderas
#' @export
RKHKernInteg <- function(Kernels, X) {
    .Call('RKHSENS_RKHKernInteg', PACKAGE = 'RKHSENS', Kernels, X)
}

#' @title Integrals of kernels
#' @description Compute integrals of kernels
#' @param Kernels List of kernels
#' @return List with vector integrals and complete kernel integrals
#' @author Pedro Guarderas
#' @export
RKHAnova <- function(Kernels, Integral, X) {
    .Call('RKHSENS_RKHAnova', PACKAGE = 'RKHSENS', Kernels, Integral, X)
}

#' @title Linear kernel
#' @description
#' @param h
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerLinear <- function(h, alpha = 1.0) {
    .Call('RKHSENS_RKHKerLinear', PACKAGE = 'RKHSENS', h, alpha)
}

#' @title Square kernel
#' @description
#' @param h
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerSqr <- function(h, alpha = 1.0) {
    .Call('RKHSENS_RKHKerSqr', PACKAGE = 'RKHSENS', h, alpha)
}

#' @title Triangular kernel
#' @description
#' @param h
#' @param c
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerTri <- function(h, c = 1.0, alpha = 1.0) {
    .Call('RKHSENS_RKHKerTri', PACKAGE = 'RKHSENS', h, c, alpha)
}

#' @title Exponential kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerExp <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('RKHSENS_RKHKerExp', PACKAGE = 'RKHSENS', h, sigma, theta)
}

#' @title Gaussian kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerSqrExp <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('RKHSENS_RKHKerSqrExp', PACKAGE = 'RKHSENS', h, sigma, theta)
}

#' @title MatÃ©rn kernel
#' @description
#' @param h
#' @param v
#' @param sigma
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerMatern <- function(h, v = 2.0, sigma = 1.0, theta = 1.0) {
    .Call('RKHSENS_RKHKerMatern', PACKAGE = 'RKHSENS', h, v, sigma, theta)
}

#' @title Multilog kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerMultilog <- function(h, R = 1.0) {
    .Call('RKHSENS_RKHKerMultilog', PACKAGE = 'RKHSENS', h, R)
}

#' @title Natural cubic spline kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerNatCubSpl <- function(h, R = 1.0) {
    .Call('RKHSENS_RKHKerNatCubSpl', PACKAGE = 'RKHSENS', h, R)
}

#' @title Thin plate kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerPlateSpl <- function(h, R = 1.0) {
    .Call('RKHSENS_RKHKerPlateSpl', PACKAGE = 'RKHSENS', h, R)
}

#' @title Mix kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
RKHKerMix <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('RKHSENS_RKHKerMix', PACKAGE = 'RKHSENS', h, sigma, theta)
}

#' @title Sensitiviy analysis
#' @description Computation of Sobol index
#' @param KF 
#' @param comb Combination.
#' @param X Points grid.
#' @param Gamma Cube with integral results.
#' @return Real value of sensitivity.
#' @author Pedro Guarderas
#' @export
RKHSobolIndex <- function(KF, comb, X, Gamma) {
    .Call('RKHSENS_RKHSobolIndex', PACKAGE = 'RKHSENS', KF, comb, X, Gamma)
}

#' @title Var
#' @description Computation of variance
#' @param Gamma Cube with integral results.
#' @return Real value of sensitivity.
#' @author Pedro Guarderas
#' @export
RKHSobolVar <- function(KF, Gamma) {
    .Call('RKHSENS_RKHSobolVar', PACKAGE = 'RKHSENS', KF, Gamma)
}

