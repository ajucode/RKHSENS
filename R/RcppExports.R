# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Generic weighted p-distance
#' @description Many isotropic models can be defined employing a distance. In particular this 
#' function implements a distance employing weights and different powers.
#' @param x First vector
#' @param y Second vector
#' @param w Weights for every coordinate in the vectors
#' @param p Powers for every coordinate in the vectors. To define a true norm every coordinate
#' has to be greater than 1.
#' @return Numeric value of the weighted p-distance.
#' @author Pedro Guarderas
#' @export
weight_pow_dist <- function(x, y, w, p) {
    .Call('_KRIG_weight_pow_dist', PACKAGE = 'KRIG', x, y, w, p)
}

#' @title Vector integral
#' @description Computes covariance kernel matrix
#' @param Kern
#' @param x
#' @param a
#' @param b
#' @param n
#' @return Vector with integrals
#' @author Pedro Guarderas
#' @export
integrate_kernel <- function(Kern, x, a, b, n) {
    .Call('_KRIG_integrate_kernel', PACKAGE = 'KRIG', Kern, x, a, b, n)
}

#' @title Complete kernel integral
#' @description Complete kernel integral
#' @param Kern
#' @param a
#' @param b
#' @param n
#' @return Real
#' @author Pedro Guarderas
#' @export
complete_integrate_kernel <- function(Kern, a, b, n) {
    .Call('_KRIG_complete_integrate_kernel', PACKAGE = 'KRIG', Kern, a, b, n)
}

#' @title Integrals of kernels
#' @description Compute integrals of kernels
#' @param Kernels List of kernels
#' @return List with vector integrals and complete kernel integrals
#' @author Pedro Guarderas
#' @export
vector_integrate_kernel <- function(Kernels, X) {
    .Call('_KRIG_vector_integrate_kernel', PACKAGE = 'KRIG', Kernels, X)
}

#' @title Integrals of kernels
#' @description Compute integrals of kernels
#' @param Kernels List of kernels
#' @return List with vector integrals and complete kernel integrals
#' @author Pedro Guarderas
#' @export
Kanova <- function(Kernels, Integral, X) {
    .Call('_KRIG_Kanova', PACKAGE = 'KRIG', Kernels, Integral, X)
}

#' @title Linear kernel
#' @description
#' @param h
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
linear_kernel <- function(h, alpha = 1.0) {
    .Call('_KRIG_linear_kernel', PACKAGE = 'KRIG', h, alpha)
}

#' @title Square kernel
#' @description
#' @param h
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
square_kernel <- function(h, alpha = 1.0) {
    .Call('_KRIG_square_kernel', PACKAGE = 'KRIG', h, alpha)
}

#' @title Triangular kernel
#' @description
#' @param h
#' @param c
#' @param alpha
#' @return Real value
#' @author Pedro Guarderas
#' @export
triangular_kernel <- function(h, c = 1.0, alpha = 1.0) {
    .Call('_KRIG_triangular_kernel', PACKAGE = 'KRIG', h, c, alpha)
}

#' @title Exponential kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
exp_kernel <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('_KRIG_exp_kernel', PACKAGE = 'KRIG', h, sigma, theta)
}

#' @title Gaussian kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
gaussian_kernel <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('_KRIG_gaussian_kernel', PACKAGE = 'KRIG', h, sigma, theta)
}

#' @title Spherical kernel
#' @description
#' @param h
#' @param phi
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
spherical_kernel <- function(h, phi, theta) {
    .Call('_KRIG_spherical_kernel', PACKAGE = 'KRIG', h, phi, theta)
}

#' @title MatÃ©rn kernel
#' @description
#' @param h
#' @param v
#' @param sigma
#' @return Real value
#' @author Pedro Guarderas
#' @export
matern_kernel <- function(h, v = 2.0, sigma = 1.0, theta = 1.0) {
    .Call('_KRIG_matern_kernel', PACKAGE = 'KRIG', h, v, sigma, theta)
}

#' @title Multilog kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
multilog_kernel <- function(h, R = 1.0) {
    .Call('_KRIG_multilog_kernel', PACKAGE = 'KRIG', h, R)
}

#' @title Natural cubic spline kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
nat_cubic_spline_kernel <- function(h, R = 1.0) {
    .Call('_KRIG_nat_cubic_spline_kernel', PACKAGE = 'KRIG', h, R)
}

#' @title Thin plate kernel
#' @description
#' @param h
#' @param R
#' @return Real value
#' @author Pedro Guarderas
#' @export
thin_plate_kernel <- function(h, R = 1.0) {
    .Call('_KRIG_thin_plate_kernel', PACKAGE = 'KRIG', h, R)
}

#' @title Mix kernel
#' @description
#' @param h
#' @param sigma
#' @param theta
#' @return Real value
#' @author Pedro Guarderas
#' @export
mix_kernel <- function(h, sigma = 1.0, theta = 1.0) {
    .Call('_KRIG_mix_kernel', PACKAGE = 'KRIG', h, sigma, theta)
}

#' @title Spatial covariance matrix.
#' @description To compute a Gaussian regression or interpolation is necessary use Kernel, and
#'   it is requeried to construct the spatial convariance matrix. The spatial covariance could
#'   be estimated between to sets of points X and Y and the result is not necessarily a square
#'   matrix.
#' @param X First set of spatial points.
#' @param Y Second set of spatial points.
#' @param Kern Kernel function.
#' @param symmetric If result of computation will be a square matrix, the time computation can
#'   be improved setting this parameter to TRUE, the default is FALSE.
#' @return The spatial covariance matrix.
#' @author Pedro Guarderas
#' @useDynLib KRIG
#' @importFrom Rcpp sourceCpp
#' @exportPattern("^[[:alpha:]]+")
#' @export
Kov <- function(X, Y, Kern, symmetric = FALSE) {
    .Call('_KRIG_Kov', PACKAGE = 'KRIG', X, Y, Kern, symmetric)
}

#' @title Gaussian regression
#' @description Computes Gaussian regression with a given covariance kernel
#' @param Z Observed spatial values.
#' @param X Spatial points, ubication where the Z value was observed.
#' @param Y Spatial points where it is requested to predict Z.
#' @param Kern Kernel functions.
#' @param type Type of Gaussian regression, 0 = simple interpolation, 1 = simple regression, 
#'  2 = ordinary interpolation, 3 = ordinary regression, 4 = universal interpolation, 
#'  5 = universal regression.
#' @param cinv Form to compute the inverse.
#' @return List containing the different important matrices employed for the Gaussian regression.
#' \item{W}{Predicted new values for Z}
#' \item{K}{Covariance matrix for X}
#' \item{k}{Covariance matrix between Y and X}
#' \item{J}{Inverse of the covariance matrix}
#' @author Pedro Guarderas
#' @export
Krig <- function(Z, K, k, G, g, type = "ordinary", typeinv = "syminv") {
    .Call('_KRIG_Krig', PACKAGE = 'KRIG', Z, K, k, G, g, type, typeinv)
}

#' @title Sensitiviy analysis
#' @description Computation of Sobol index
#' @param KF 
#' @param comb Combination.
#' @param X Points grid.
#' @param Gamma Cube with integral results.
#' @return Real value of sensitivity.
#' @author Pedro Guarderas
#' @export
sens_idx <- function(KF, comb, X, Gamma) {
    .Call('_KRIG_sens_idx', PACKAGE = 'KRIG', KF, comb, X, Gamma)
}

#' @title Var
#' @description Computation of variance
#' @param Gamma Cube with integral results.
#' @return Real value of sensitivity.
#' @author Pedro Guarderas
#' @export
sens_var <- function(KF, Gamma) {
    .Call('_KRIG_sens_var', PACKAGE = 'KRIG', KF, Gamma)
}

